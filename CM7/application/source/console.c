/*
 * console.c
 *
 * Task for handling all UART debug port
 * 
 * Created: 11/17/2018 12:31:46 AM
 *  Author: Sofian.jafar
 */ 


#include "console.h"

#include <stdio.h>
#include <stdarg.h>
#include <string.h>

#include "usbd_cdc_if.h"

#include "stdio.h"

#include "application_commands.h"
#include "taskstats.h"
#include "application_config.h"

#include "stm32h747xx.h"
#include "shared_data.h"
#include "registers.h"

/* Dimensions the buffer into which input characters are placed. */
#define cmdUART_MAX_INPUT_SIZE	60

/* Dimensions the buffer into which string outputs can be placed. */
#define cmdUART_MAX_OUTPUT_SIZE	1024

/* DEL acts as a backspace. */
#define cmdASCII_DEL		( 0x7F )

// Task handles
TaskHandle_t xCreatedAppUSBCLITask;
TaskHandle_t xCreatedAppUSBInfoTask;

static SemaphoreHandle_t                UART_mutex;

/*
 * Various buffers used by the command line interpreter.
 */
static char cOutputString[ cmdUART_MAX_OUTPUT_SIZE ];
static char cInputString[ cmdUART_MAX_INPUT_SIZE ];

/* Const messages output by the command console. */
static const char * const pcNewLine = "\r\n";

/**
 * \brief Dump statistics to console
 */
static void _os_show_statistics(void);

static bool UART_mutex_take(void);
static void UART_mutex_give(void);
static void str_write(const char *s);
static void char_write(unsigned char s);

static void task_app_usb_info_pause(bool pause)
{
    if (pause)
    {
        vTaskSuspend(xCreatedAppUSBInfoTask);
    }
    else
    {
        vTaskResume(xCreatedAppUSBInfoTask);
    }
}

/**
 * OS task that monitor console inputs and do actions
 */
static void app_usb_CLI_task(void *pvParameters)
{
    char        cRxedChar;
    uint8_t     ucInputIndex = 0;
    BaseType_t  xReturned;
    bool        ucUSBInfoSuspended = false;

    union {
    uint32_t                xReceived_message;
    usbd_cdc_input_char_t   *RxData;
    } message;

	( void ) pvParameters;

    // suspend the info task to stop cpu consumption when not needed
    // TODO: Uncomment the lines below
//    task_app_usb_info_pause(true);
//    ucUSBInfoSuspended = true;
    
    // store the task number for deciding control priority later
    USBTaskNumber = pxGetCurrentTaskNumber();

	vTaskDelay(portTICK_PERIOD_MS * 5000);

    // remove all unhandled notifications
    xTaskNotifyStateClear( xCreatedAppUSBCLITask );

    for( ;; )
	{
		/* Task will be notified of any new characters by CDC_Receive_HS interrupt function */

        // wait for data to be received
        xTaskMessageWait(&message.xReceived_message);
        
        cRxedChar = message.RxData->inputChar;

		/* Ensure exclusive access to the UART Tx. */
		if( UART_mutex_take() )
		{
			/* Echo the character back. */
            char_write(cRxedChar);

			/* Was it the end of the line? */
			if( ( cRxedChar == '\n' ) || ( cRxedChar == '\r' ) )
			{
				/* Just to space the output from the input. */
                str_write(pcNewLine);

				/* See if the command is empty, indicating that info task is
                to be toggled. */
				if( ucInputIndex == 0 )
				{
					// toggle the Info task display
					if (ucUSBInfoSuspended)
                    {
                        task_app_usb_info_pause(false);
                        ucUSBInfoSuspended = false;
                    }
                    else
                    {
                        task_app_usb_info_pause(true);
                        ucUSBInfoSuspended = true;
                    }
				}
                else
                {
                    /* Pass the received command to the command interpreter.  The
                    command interpreter is called repeatedly until it returns
                    pdFALSE	(indicating there is no more output) as it might
                    generate more than one string. */
                    do
                    {
                        /* Get the next output string from the command interpreter. */
                        cOutputString[ 0 ] = 0x00;
                        xReturned = FreeRTOS_CLIProcessCommand( cInputString, cOutputString, cmdUART_MAX_OUTPUT_SIZE );

                        /* Write the generated string to the UART. */
                        str_write(cOutputString);

                    } while( xReturned != pdFALSE );
                }

				/* All the strings generated by the input command have been
				sent.  Clear the input string ready to receive the next command.*/
				ucInputIndex = 0;
				memset( cInputString, 0x00, cmdUART_MAX_INPUT_SIZE );
			}
			else
			{
				if( cRxedChar == '\r' )
				{
					/* Ignore the character. Newlines are used to
					detect the end of the input string. */
				}
				else if( ( cRxedChar == '\b' ) || ( cRxedChar == cmdASCII_DEL ) )
				{
					/* Backspace was pressed.  Erase the last character in the
					string - if any. */
					if( ucInputIndex > 0 )
					{
						ucInputIndex--;
						cInputString[ ucInputIndex ] = '\0';
					}
				}
				else
				{
					/* A character was entered.  Add it to the string entered so
					far.  When a \n is entered the complete	string will be
					passed to the command interpreter. */
					if( ( cRxedChar >= ' ' ) && ( cRxedChar <= '~' ) )
					{
						if( ucInputIndex < cmdUART_MAX_INPUT_SIZE )
						{
							cInputString[ ucInputIndex ] = cRxedChar;
							ucInputIndex++;
						}
					}
				}
			}

			/* Must ensure to give the mutex back. */
			UART_mutex_give();
		}
	}
}

/**
 * OS task that monitor system status and show statistics every second
 */
static void app_usb_info_task(void *p)
{
    (void)p;
    
    vTaskDelay(portTICK_PERIOD_MS * 5000);
    for (;;) {
        
        if (UART_mutex_take()) 
            {
                _os_show_statistics();
                UART_mutex_give();
            }
        vTaskDelay(portTICK_PERIOD_MS * 1000);
    }
}

static void UART_mutex_create(void)
{
    UART_mutex = xSemaphoreCreateMutex();

    if (UART_mutex == NULL) {
        while (1) {
            ;
        }
    }
}

static bool UART_mutex_take(void)
{
    return xSemaphoreTake(UART_mutex, ~0);
}

static void UART_mutex_give(void)
{
    xSemaphoreGive(UART_mutex);
}

/**
 * \brief Write string to console
 */
static void str_write(const char *s)
{
	uint32_t trialCount = 0;

    while (CDC_Transmit_HS((uint8_t *)s, strlen(s)) == USBD_BUSY) 
    {   
        vTaskDelay(1);
        trialCount++;
        /* If there were more than 10 unsuccessful trials it means the USB is not connected
           Try again in 1 seconds */
        if (trialCount > 10)
        {
            trialCount = 0;
            vTaskDelay(1000);
        }
    }
}

/**
 * \brief Write character to console
 */
static void char_write(unsigned char s)
{
	uint32_t trialCount = 0;

	while (CDC_Transmit_HS( &s, 1) == USBD_BUSY)
    {   
        vTaskDelay(1);
        trialCount++;
        /* If there were more than 10 unsuccessful trials it means the USB is not connected
           Try again in 1 seconds */
        if (trialCount > 10)
        {
            trialCount = 0;
            vTaskDelay(1000);
        }
    }
}

/**
 * \brief Dump statistics to console
 */
static void _os_show_statistics(void)
{
    // create two buffers to alternate between them so that USB does not mix data
    static portCHAR szList1[1024], szList2[1024];
    
    uint32_t ulIPAddress, ulNetMask, ulGatewayAddress, ulDNSServerAddress;
    char cBuffer[ 16 ];

    sprintf(szList1, "%c%c%c%c", 0x1B, '[', '2', 'J');
    str_write(szList1);
    sprintf(szList2, "--- Number of tasks: \t\t\t%u\r\n", (unsigned int)uxTaskGetNumberOfTasks());
    str_write(szList2);
    sprintf(szList1, "--- Free Heap: \t\t\t\t%d\r\n", (int)xPortGetFreeHeapSize());
    str_write(szList1);
    sprintf(szList2, "--- Minimum Free Heap: \t\t\t%d\r\n", (int)xPortGetMinimumEverFreeHeapSize());
    str_write(szList2);
    sprintf(szList1, "--- Free Network Buffers: \t\t%d\r\n", (unsigned int)uxGetNumberOfFreeNetworkBuffers());
    str_write(szList1);
    sprintf(szList2, "--- Minimum Free Network Buffers: \t%d\r\n", (unsigned int)uxGetMinimumFreeNetworkBuffers());
    str_write(szList2);
   sprintf(szList1, "--- Time since startup [s]: \t\t%0.4f\r\n", ((float)ullGetRunTimeCounterValue()) / 10000);
   str_write(szList1);
    str_write("\nTasks Statistics:\r\n");
    taskStats(szList2);
    str_write(szList2);

    /* Print out the network configuration, which may have come from a DHCP
        server. */
   if (xGetPhyLinkStatus() == pdPASS)
   {
       sprintf(szList1, "\r\nPhy Link UP\r\n");
   }
   else
   {
       sprintf(szList1, "\r\nPhy Link DOWN\r\n");
   }
   str_write(szList1);
    
   FreeRTOS_GetAddressConfiguration( &ulIPAddress, &ulNetMask, &ulGatewayAddress, &ulDNSServerAddress );
   FreeRTOS_inet_ntoa( ulIPAddress, cBuffer );
   str_write("IP Address:  ");
   str_write(cBuffer);
   str_write("\n\n\r");

    str_write("--- Press ENTER to stop the info print\r\n");

    str_write(cInputString);
}

#define _SPRINTF_OVERRIDE 0
#if _SPRINTF_OVERRIDE
/* Override sprintf implement to optimize */

static const unsigned m_val[] = {1000000000u, 100000000u, 10000000u, 1000000u, 100000u, 10000u, 1000u, 100u, 10u, 1u};
int                   sprintu(char *s, unsigned u)
{
    char tmp_buf[12];
    int  i, n = 0;
    int  m;

    if (u == 0) {
        *s = '0';
        return 1;
    }

    for (i = 0; i < 10; i++) {
        for (m = 0; m < 10; m++) {
            if (u >= m_val[i]) {
                u -= m_val[i];
            } else {
                break;
            }
        }
        tmp_buf[i] = m + '0';
    }
    for (i = 0; i < 10; i++) {
        if (tmp_buf[i] != '0') {
            break;
        }
    }
    for (; i < 10; i++) {
        *s++ = tmp_buf[i];
        n++;
    }
    return n;
}

int sprintf(char *s, const char *fmt, ...)
{
    int     n = 0;
    va_list ap;
    va_start(ap, fmt);
    while (*fmt) {
        if (*fmt != '%') {
            *s = *fmt;
            s++;
            fmt++;
            n++;
        } else {
            fmt++;
            switch (*fmt) {
            case 'c': {
                char valch = va_arg(ap, int);
                *s         = valch;
                s++;
                fmt++;
                n++;
                break;
            }
            case 'd': {
                int vali = va_arg(ap, int);
                int nc;

                if (vali < 0) {
                    *s++ = '-';
                    n++;
                    nc = sprintu(s, -vali);
                } else {
                    nc = sprintu(s, vali);
                }

                s += nc;
                n += nc;
                fmt++;
                break;
            }
            case 'u': {
                unsigned valu = va_arg(ap, unsigned);
                int      nc   = sprintu(s, valu);
                n += nc;
                s += nc;
                fmt++;
                break;
            }
            case 's': {
                char *vals = va_arg(ap, char *);
                while (*vals) {
                    *s = *vals;
                    s++;
                    vals++;
                    n++;
                }
                fmt++;
                break;
            }
            default:
                *s = *fmt;
                s++;
                fmt++;
                n++;
            }
        }
    }
    va_end(ap);
    *s = 0;
    return n;
}
#endif /* _SPRINTF_OVERRIDE */

/**
 * \brief Create OS task for console input/output
 */
static void task_app_usb_CLI_create(void)
{
    /* Create the task that handles the CLI. */
    if (xTaskCreate(
            app_usb_CLI_task, USB_CLI_TASK_NAME, USB_CLI_TASK_STACK_SIZE, NULL, USB_CLI_TASK_PRIORITY, &xCreatedAppUSBCLITask)
        != pdPASS) {
        while (1) {
            ;
        }
    }
}

/**
 * \brief Create OS task for system status on debug UART
 */
static void task_app_usb_info_create(void)
{
    /* Create task to monitor processor activity */
    if (xTaskCreate(
            app_usb_info_task, USB_INFO_TASK_NAME, USB_INFO_TASK_STACK_SIZE, NULL, USB_INFO_TASK_STACK_PRIORITY, &xCreatedAppUSBInfoTask)
        != pdPASS) {
        while (1) {
            ;
        }
    }
}

void usb_uart_start(void)
{
    UART_mutex_create();

    // maintain order in creating the tasks here because the CLI taks suspends info task
    task_app_usb_info_create();
    task_app_usb_CLI_create();
}
